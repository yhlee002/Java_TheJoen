
public class OpEx07 {
	public static void main(String[] args) {
		/* 비트연산자 *가독성이 떨어져 잘 쓰이지 않음, 비트연산자도 복합 대입이 가능하다.
		 * 비트(bit) : 데이터를 나타내는 최소 단위(0 또는 1이 하나의 bit가 된다.)
		 * 하나의 비트는 두가지 수를 나타낼 수 있으므로 n개의 비트는 2ⁿ만큼의 가지수를 나타낼 수 있다.
		 * 
		 * cf. 보수(2의 보수)
		 * 0000 0000 : 0, 01111 1111 : 127, 1000 0000 : -128
		 * (0111 1111에서 1이 증가해서 1000 0000이 되면 -128부터 세는 것이 순서)
		 * 
		 * 음수인 byte값을 알아보기 쉽게 하기 위해 '2의 보수'라는 방법 사용
		 * 수의 0과 1을 반전시켜 양수값을 구해 그 값에 '1'을 더하고
		 * ex)1000 0001 --> 0111 1110 + 1 = 0111 1111 : 127 여기에 '-'를 붙이면 된다.
		 * 
		 * 1byte(8bit) : -128~127(첫번째 자리 수가 1이면 음수, 0이면 양수)
		 */
		byte num1 = 0b00000001; //0b : 2진수로 표현하는 기호(뒤의 수가 2진수임을 명시)
		System.out.println(num1);
		num1 = (byte) 0b10000000; //Java가 0b10000000을 int형으로 인식, -0이 아닌 -128
		System.out.println(num1);
		num1 = (byte) 0b10000001; //0b10000010은 -126, 0b10000011은 -125
		System.out.println(num1);
		num1 = (byte) 0b01111111;
		System.out.println(num1);
		
		byte a = (byte)0b00000100;
		System.out.println("a : "+a); //a = 4
		
		byte b = (byte)0b00011110; //2+4+8+16 = 30
		System.out.println("b : "+b);
		
		/*
		 * <<, >> (쉬프트 연산자) : '대상 >> 이동할 횟수'or'대상 << 이동할 횟수'와 같은 방식으로 사용.
		 * ex) a >> 1 : 0000 0010, b >> 2 : 0000 0111
		 */
		System.out.println("a >> 1 : "+(a>>1)); // = a/2
		System.out.println("a >> 2 : "+(a>>2)); //오른쪽으로의 이동은 한 칸 당 2ⁿ로 나누는 값이 된다.(<->왼쪽 : 곱하기)
		System.out.println("b >> 2 : "+(b>>2)); //7.5가 나오나 int형으로 표현되기 때문에 소수점없이 7이 그 값이 된다.
		
		/*
		 * byte a = (byte)0b00000100 //4
		 * byte b = (byte)0b00011110 //30
		 * 				=0b00000100
		 * '&' : 숫자인 값을 &연산할 경우 같은 자리에 있는 bit를 비교하여 AND연산
		 * 두 자리를 비교하여 둘 다 참(1)인 경우 참(1), 하나라도 거짓(0)이라면 거짓(0)
		 * cf. '|'(비트OR연산자)의 경우 두 자리 중 하나라도 참(1)이면 참(1)
		 */
		
		System.out.println("a&b : "+(a&b)); //bit값에는 논리 연산자를 사용할 수 없다.(비트 연산자만 사용 가능) --> 4 출력
		System.out.println("a|b : "+(a|b));
		
		/*'~'(비트 NOT연산자) : 0을 1으로, 1을 0으로 바꿈
		 * 		ex)~b : 00011110
		 * 			 = 	11100001 --> 00011111 : -(1+2+4+8+16) = -31
		 */
		System.out.println("~b : "+(~b));
		
		/*'^'(XOR ; exclusive OR) : 두 수를 비교해 다른 경우 1, 같을 경우 0로 계산
		 * 		ex) 00000100
		 * 	 		00011110
		 * 	 	=	00011010
		 */

		System.out.println("a^b : "+(a^b));

	}
}
